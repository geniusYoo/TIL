# 5장 - Priority Queue

- Heap
    - 데이터 풀이 계속해서 변경될 때 가장 크거나 작은 수를 `O(logN)` 만에 찾을 수 있는 이진 트리 형태의 자료구조
    - 데이터를 넣을 때 반 쯤 정렬된 상태로 삽입됨 `O(logN)` → 완전히 정렬되어있는 상태가 아니기 때문에 iteration 돌려서 찾으면 안됨, 메소드 사용해서 꺼내야 함
    - 데이터를 꺼낼 때는 가장 크거나 작은 값을 꺼냄 `O(logN)`
    - 가장 작은 데이터부터 꺼내는 힙을 *min heap*
    - 가장 큰 데이터부터 꺼내는 힙을 *max heap*
    - N개의 데이터를 모두 힙에 넣었다가 모든 데이터를 꺼내면 `O(logN)`
    - 시간복잡도는 같지만 데이터 풀의 변화가 없으면 정렬 API가 평균적으로 더 빠름

- Priority Queue
    - 시간복잡도
        - 데이터 삽입, 우선순위가 가장 크거나 작은 데이터 접근/삭제 → `O(logN)`
        - i번째 데이터에 접근,삽입,삭제 → `O(NlogN)`
        - 어떠한 데이터가 존재하는지 탐색 (iteration 돌려야 함) → `O(N)`
    - Heap 자료구조를 사용하여 구현되어 있음
    - **기업 코테 출제 빈도 매우 높음 ⭐️⭐️**

- 2^31 = 4byte = int !!!
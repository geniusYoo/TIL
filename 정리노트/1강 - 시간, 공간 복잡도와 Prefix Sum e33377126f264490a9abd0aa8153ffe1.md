# 1강 - 시간, 공간 복잡도와 Prefix Sum

- 숏코딩이 무조건 좋은 게 아니다. 소스 길이와 시간은 비례하지 않으니까 주의!
- 백준 실버~골드는 풀수 있어야 대기업 코딩테스트는 합격할 수 있음

## 시간 복잡도

- 시간복잡도는 1억번 연산에 1초 걸린다고 생각하면 됨
- **Java에서는 숫자 쓸 때 언더바 붙여도 무시됨**
    - 예) `private int MAX = 100_000` → OK!
- 로직을 짤 때 처음부터 시간초과 오답으로 되지 않도록 해야함, 불필요한 코드 작성하지 않도록
- 이래서 **시간복잡도**가 중요함 !!
- Arrays.sort(arr) 퀵정렬 → 시간복잡도는 `O(nlogn)` .. 엄청 오래걸림 ..
- 최악의 케이스에서는 퀵정렬의 시간복잡도가 `O(n^2)` (n제곱) → 인위적으로 만들지 않는 한 거의 ..
- Integer같은 레퍼런스 타입을 이용해서 Collections.sort을 쓰면 이 API에 해당하는 알고리즘의 시간복잡도는 최악의 케이스에서도 `O(nlogn)` 을 보장함
- 정렬 알고리즘에서 reference 타입을 정렬하느냐 primitive 타입을 정렬하느냐에 따라 시간복잡도가 달라지는 이유
    - reference type - stable sort → ex) Collections.sort
    - primitive type - unstable sort → ex) Arrays.sort (퀵정렬)
- 코테에서는 퀵정렬 그냥 사용해도 됨, 인위적으로 하진 않을 것
- 컴퓨터 사이언스에서는 log가 밑이 2인 log임 !
- **2^31 = 21억** .. 이건 기억해두자 !~
- 대부분 문제들은 시간복잡도가 nlogn 안으로 풀어야 함 ..
    - 1초 → 100,000,000 (1억) 회 연산 가능
    - 0.1초 → 10,000,000 (1천만) 회 연산 가능
    - 일반적인 코테에서 특별한 명시가 없다면, 제한시간은 약 1~5초
- **** 시간복잡도 계산 결과 연산양이 1억 이상이면 거의 100% 시간초과**

![스크린샷 2023-01-20 21.52.56.png](1%E1%84%80%E1%85%A1%E1%86%BC%20-%20%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB,%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%83%E1%85%A9%E1%84%8B%E1%85%AA%20Prefix%20Sum%20e33377126f264490a9abd0aa8153ffe1/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-20_21.52.56.png)

## 공간 복잡도

- int 1개 = 4byte = 32bit
- 1byte = 8bit
- 21억 = 2^31
    - 맨 앞은 부호비트, 나머지 31비트로 표현 (음수를 표현할 방법이 없기 때문)
    - -21억~ +21억까지 숫자 표현 가능
    - 21억가지의 숫자 표현이 가능함, 이를 넘으면 overflow → 에러는 안나는데 원하지 않는 결과값이 나옴 (예를들어 음수)
- float 타입의 소수점을 곱할 때 정확도 이슈
    - 컴퓨터는 이진법을 쓰기때문에 십진법의 소수점 곱하기와는 정확도 다름
    - 0.1f * 0.1f = 0.01f Xxxx
    - 컴퓨터는 0.1f = 0.000011000001010101010100… 이런 무한대의 수기 때문에 어디선가는 잘라야 함
    - 그래서 0.1f = 0.001001001 이런 식으로 뒤가 1로 끝남
    - 그래서 0.1f * 0.1f = 0.010000001 이런 식으로 나옴!
- 배열 만들 때 메모리를 신경 쓰면서 만들어야함 → 너무 크게만 안잡으면 됨
    - 예) int [][] arr = new int[100000][100000] → 메모리 초과
- int형 2억개 이상이면 거의 100% 메모리초과
- 일반적으로 코테에서 1GB 이상 안 줄 것임
    
    ![스크린샷 2023-01-20 22.39.36.png](1%E1%84%80%E1%85%A1%E1%86%BC%20-%20%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB,%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%83%E1%85%A9%E1%84%8B%E1%85%AA%20Prefix%20Sum%20e33377126f264490a9abd0aa8153ffe1/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-20_22.39.36.png)
    
- int가 연산 속도가 가장 빠르기 때문에, 꼭 필요한 경우가 아니면 Long, Double 같은 자료형 사용하면 시간초과 가능성

> **문제 풀이법을 고민할 때, 시간/공간 복잡도를 고려해야 함. 이걸 고려하지 않은 풀이는 정답으로 간주하지 않음 !!**
> 

## Prefix Sum_ 누적합

- 데이터가 불변인 경우 쓰는 테크닉
- 0 5 4 3 2 1 → 불변
- 0 5 9 12 14 15 (0, 0+5, 0+5+4, 0+5+4+3, 0+5+4+3+2, 0+5+4+3+2+1) → O(n)
- index 1~3 합 = 3번-(1번-1) = 12-0 = 12 → O(1)
- index 2~4 합 = 4번-1번 = 14-5 = 9

- 콩나물을 길러요
    - 처음엔 높이가 0
    - 다음날에 index3~7 까지 높이 +3
    - 또 다음날에 index1~4 까지 높이 +4
    - 마지막날에 index7~8 까지 높이+2
- 3~7까지 높이 +3이면
    - index3에 +3, index(7+1=8)에 -3
- 나머지도
    - index1에 +4, index5에 -4
    - index7에 +2, index9에 -2
- 이렇게 하면 4 0 3 0 -4 0 2 -3 -2
- 이걸 누적합으로 더해주면
    - 4 4 7 7 3 3 5 2
    - 원하는 값을 얻을 수 있음
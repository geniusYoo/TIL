# HashMap vs TreeMap

<br>

프로젝트를 하는 도중, 대용량 데이터 처리를 `<key,value>` 쌍으로 처리할 일이 생겼다. 

적절한 자료구조를 선택해야 타임 오버헤드를 줄일 수 있을텐데 ..하는 생각부터 시작되었다.

<br>

### **HashMap**

### 장점

- `데이터의 삽입, 삭제`가 O(1)로 매우 빠름 -> 대용량의 데이터를 삽입, 삭제하는 경우 적합

- `key로 value에 접근`하는 것도 O(1)로 매우 빠름

- `어떠한 key가 존재하는지` 검색하는 것도 O(1)로 매우 빠름

- Map이기 때문에 key는 중복 불가능, value는 중복 가능하므로 `중복 제거` 용도로도 많이 쓰임


### 단점

- 대신, `value로 key를 찾는 건` 하나하나 Iteration 돌려야 하기 때문에 느림

- 또한 Hash 키 값을 이용해서 저장하기 때문에 `데이터가 정렬되어 있지 않음`

<br>

### **TreeMap**

### 장점

- `데이터가 정렬되어 있음`. 

    -  키는 저장과 동시에 자동 오름차순으로 정렬되고 타입이 숫자일 경우 값으로, 문자열일 경우 유니코드로 정렬한다. 

- `Red-Black Tree`

    - 레드 블랙 트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽 자식으로, 큰 값을 가지는 노드는 오른쪽 자식으로 배치하여 데이터의 추가나 삭제 시 트리가 한 쪽으로 치우쳐지지 않도록 균형을 맞추어준다.


### 단점

- `데이터의 삽입, 삭제`가 HashMap에 비해 느림 -> 데이터를 삽입하면서 자동 정렬을 하기 때문

- `key로 value에 접근`하는 것도 느림


<br>

### **결론**

기능에 따라서 선택하면 된다.

정렬된 데이터를 조회해야 하는 경우 `TreeMap`

정렬되어 있을 필요가 없고 데이터의 삽입, 삭제 빈도가 많은 경우 `HashMap`


<br>

### **예시**

```java
HashMap<LocalDate, DayInfo> options = new HashMap<>();

class DayInfo {
    HashMap<Timestamp, List<String>> conflictUsersByTime; 

    public DayInfo() {

    }
}
```
    

<br>

*우리는 데이터의 삽입, 삭제가 많고 데이터의 양도 많을 뿐더러 정렬되어 있을 필요는 없어서 HashMap을 선택했다 !*